---
title          : Course Pack
layout         : page
permalink: /
---

**Important note**: This is a temporary location for the CS421/521
Course Pack.  I suggest that you *not* bookmark this URL, as I expect
the location of this site to change.  At least for the time being,
find this page via the [Class
resources](https://uwlac.instructure.com/courses/334351/pages/class-resources)
page of the course Canvas area.

This document contains material for the Fall 2020 offering of UWL
CS421/521, Concepts of Programming Languages.  Some links on this page
will require access to the UWL VPN or Canvas LMS.

## About this class

  - Syllabus: Will be released before the first week of class
  - [Announcements](https://uwlac.instructure.com/courses/334351/pages/announcements?module_item_id=6031626):
    The LMS page where I will post class announcements
  - Intro: What we will study, and
    why it is important 
  - [Getting started]({{ site.baseurl }}/Setup/): Setting up Agda
    and other programs on your machine
  - [Sources]({{ site.baseurl }}/Sources/): Sources and authors of the
    material in this course pack

## Functional programming

  - TODO
    - Develop pattern matching discussion: point out where we are
      using patterns in new ways
  - [Basics]({{ site.baseurl }}/Basics/): The basics of functional
    programming
  - [Naturals]({{ site.baseurl }}/Naturals/): Natural numbers
  - [NatData]({{ site.baseurl }}/NatData/): Data structures using
    natural numbers
  - [Poly]({{ site.baseurl }}/Poly/): Generic data structures and functions
  - [Functional]({{ site.baseurl }}/Functional/): Higher-order functions
  - [Maps]({{ site.baseurl }}/Maps/): Partial and total maps
  - [Depend]({{ site.baseurl }}/Depend/): Dependent types

  - [Lists]({{ site.baseurl }}/Lists/): Lists and higher-order functions


## Verified functional programming

  - TODO
    - Explain need for totality for logic/proof
  - [Induction]({{ site.baseurl }}/Induction/): Proof by induction
  - [Relations]({{ site.baseurl }}/Relations/): Inductive definition of relations
    - [Equality]({{ site.baseurl }}/Equality/): Equality and equational reasoning

  - [Isomorphism]({{ site.baseurl }}/Isomorphism/): Isomorphism and embedding

  - Elements of logic in Agda
    - [Connectives]({{ site.baseurl }}/Connectives/): Conjunction, disjunction, and implication
    - [Negation]({{ site.baseurl }}/Negation/): Negation, with intuitionistic and classical logic
    - [Quantifiers]({{ site.baseurl }}/Quantifiers/): Universals and existentials
  - [Decidable]({{ site.baseurl }}/Decidable/): Booleans and decision procedures
  - DataProp: Proving properties about pairs, lists, and maps

## Imperative programming
  - Imp: A small imperative language, and its operational semantics
  - Equiv: What does it mean for imperative programs to be equivalent
  - Hoare: A compositional semantics for imperative programs
  - Step: An alternative operational semantics
  - Additional topics to be posted

## Lambda calculus

  - [Lambda]({{ site.baseurl }}/Lambda/): Introduction to Lambda Calculus
  - [Properties]({{ site.baseurl }}/Properties/): Progress and Preservation

- Material to be posted

## Objects and classes
  - Material to be posted


## Advanced lambda calculus

  - [DeBruijn]({{ site.baseurl }}/DeBruijn/): Intrinsically-typed de Bruijn representation
  - [More]({{ site.baseurl }}/More/): Additional constructs of simply-typed lambda calculus
  - [Bisimulation]({{ site.baseurl }}/Bisimulation/): Relating reductions systems
  - [Inference]({{ site.baseurl }}/Inference/): Bidirectional type inference
  - [Untyped]({{ site.baseurl }}/Untyped/): Untyped lambda calculus with full normalisation
  - [Confluence]({{ site.baseurl }}/Confluence/): Confluence of untyped lambda calculus ðŸš§
  - [BigStep]({{ site.baseurl }}/BigStep/): Big-step semantics of untyped lambda calculus ðŸš§

## Denotational Semantics

  - [Denotational]({{ site.baseurl }}/Denotational/): Denotational semantics of untyped lambda calculus ðŸš§
  - [Compositional]({{ site.baseurl }}/Compositional/): The denotational semantics is compositional ðŸš§
  - [Soundness]({{ site.baseurl }}/Soundness/): Soundness of reduction with respect to denotational semantics ðŸš§
  - [Adequacy]({{ site.baseurl }}/Adequacy/): Adequacy of denotational semantics with respect to operational semantics ðŸš§
  - [ContextualEquivalence]({{ site.baseurl }}/ContextualEquivalence/): Denotational equality implies contextual equivalence ðŸš§

## Substitution

  - [Substitution]({{ site.baseurl }}/Substitution/): Substitution in untyped lambda calculus

