---
title          : Programming Language Concepts
layout         : page
permalink: /
---

## About this class

  - [Getting started]({{ site.baseurl }}/Setup/): Setting up Agda and
    other programs on your machine
    - [Troubleshooting]({{ site.baseurl }}/Troubleshooting/): Some
      common problems in configuring your Agda installation
  - [Sources]({{ site.baseurl }}/Sources/): Sources and authors of the
    material in this course pack

## Functional programming

  - [Basics]({{ site.baseurl }}/Basics/): The basics of functional
    programming
  - [Naturals]({{ site.baseurl }}/Naturals/): Natural numbers
  - [NatData]({{ site.baseurl }}/NatData/): Data structures using
    natural numbers
  - [Poly]({{ site.baseurl }}/Poly/): Generic data structures and functions
  - [Functional]({{ site.baseurl }}/Functional/): Higher-order functions
  - [Maps]({{ site.baseurl }}/Maps/): Partial and total maps
  - [Depend]({{ site.baseurl }}/Depend/): Dependent types

## Verified functional programming

  - [Induction]({{ site.baseurl }}/Induction/): Proof by induction
  - [DataProp]({{ site.baseurl }}/DataProp/): Properties of data structures
  - [MapProps]({{ site.baseurl }}/MapProps/): Properties of total and partial maps
  - [Relations]({{ site.baseurl }}/Relations/): Inductive definition of relations
  - [DataRel]({{ site.baseurl }}/DataRel/): Relations for data structures
  - [Logic]({{ site.baseurl }}/Logic/): Connectives and deduction

## Logic and computation
  - [Equality]({{ site.baseurl }}/Equality/): Equality and equational reasoning
  - [Isomorphism]({{ site.baseurl }}/Isomorphism/): Isomorphism and embedding
  - [LogicRedux]({{ site.baseurl }}/LogicRedux/): A deeper look at the basic connectives
  - [Quantifiers]({{ site.baseurl }}/Quantifiers/): Universals and existentials
  - [Decidable]({{ site.baseurl }}/Decidable/): Booleans and decision procedures

## Incomplete

### Imperative programming
  - [Imp]({{ site.baseurl }}/Imp/): A small imperative language, and
    its operational semantics
  - Equiv: What does it mean for two imperative programs to be equivalent?
  - Hoare: A compositional semantics for imperative programs
  - Step: An alternative operational semantics
  - Additional topics to be posted

### Lambda calculus

  - [Lambda]({{ site.baseurl }}/Lambda/): Introduction to Lambda Calculus
  - [Properties]({{ site.baseurl }}/Properties/): Progress and Preservation

- Material to be posted

### Objects and classes
  - Material to be posted

### Advanced lambda calculus

  - [DeBruijn]({{ site.baseurl }}/DeBruijn/): Intrinsically-typed de Bruijn representation
  - [More]({{ site.baseurl }}/More/): Additional constructs of simply-typed lambda calculus
  - [Bisimulation]({{ site.baseurl }}/Bisimulation/): Relating reductions systems
  - [Inference]({{ site.baseurl }}/Inference/): Bidirectional type inference
  - [Untyped]({{ site.baseurl }}/Untyped/): Untyped lambda calculus with full normalisation
  - [Confluence]({{ site.baseurl }}/Confluence/): Confluence of untyped lambda calculus ðŸš§
  - [BigStep]({{ site.baseurl }}/BigStep/): Big-step semantics of untyped lambda calculus ðŸš§

### Denotational Semantics

  - [Denotational]({{ site.baseurl }}/Denotational/): Denotational semantics of untyped lambda calculus ðŸš§
  - [Compositional]({{ site.baseurl }}/Compositional/): The denotational semantics is compositional ðŸš§
  - [Soundness]({{ site.baseurl }}/Soundness/): Soundness of reduction with respect to denotational semantics ðŸš§
  - [Adequacy]({{ site.baseurl }}/Adequacy/): Adequacy of denotational semantics with respect to operational semantics ðŸš§
  - [ContextualEquivalence]({{ site.baseurl }}/ContextualEquivalence/): Denotational equality implies contextual equivalence ðŸš§

### Substitution

  - [Substitution]({{ site.baseurl }}/Substitution/): Substitution in untyped lambda calculus
